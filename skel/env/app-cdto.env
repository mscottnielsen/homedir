##############################################################################
# Edit and save frequently used directories to a list (like popd, pushd); use
# "cdw" to easily chdir to remembered directories by pattern or recently used.
#
# Usage:
#   $ setwk            # add $PWD to the end of the remembered list
#   $ editw            # use $EDITOR to edit  directory list
#   $ listw {pattern}  # show existing working dirs matching the pattern
#   $ cdw {pattern}    # chdir to the directory matching the pattern
#                      #   (most recently used match)
#   $ cdw {pattern} {prefix1} {prefix2}
#                      # cd to directory matching {pattern}, then into
#                      #   subdirectory matching the given prefixes.
#                      #   e.g., cd *{pattern}*/prefix1*/prefix2*
#

############################################################################
# list of current working dirs (move old .workrc files into .workrcd/)
export WORKRC=~/.workrcd/${h_host:-$(hostname)}.workrc
export WORKRC_DEFAULT=~/.workrcd/default.workrc

mkdir -p ${WORKRC%/*}
# use a generic workrc until a real one is used (don't autocreate $WORKRC)
[ ! -f $WORKRC_DEFAULT ]  && pwd > $WORKRC_DEFAULT

# legacy conversion (deprecated)
#OLD_WORKRC=~/.workrc.${h_host:-$(hostname)}
#[ -f "$OLD_WORKRC" -a ! -f "$WORKRC" ] && mv -i "$OLD_WORKRC" "$WORKRC"


############################################################################
get_workrc_default () {
  [ ! -f "$WORKRC_DEFAULT" ] && touch $WORKRC_DEFAULT
  echo $WORKRC_DEFAULT
}

############################################################################
# get the file containing the list of workign directories, or if not found,
# return some default list (do not use this to return the file to write to,
# just to read from)
get_workrc () {
  [ -f "$WORKRC" ] && echo $WORKRC || get_workrc_default
}

############################################################################
# chdir to directory, given approximate path(s), using wildcards to complete.
# Usage:  cdto basepath [pattern ...]
# Example:
#  $ cdto /some/dir apple berry choc don
#      add wildcard => cd /some/dir/apple/berry/choc*/don*/
#      expands to   => cd /some/dir/apple/berry/chocolate/donuts/
#  Notes:
#    * append wildcard (*) to directories that are not an exact match ('apple'
#       and 'berry' do exist; 'choc' and 'don' do not, so use: choc* and don*)
#    * if match multiple directories match, 'cd' into the first match
#
cdto () {
  usage() { cat<<EOF
  Usage: cdto path pattern pattern ...
    cd to a previously remembered directory matching the given pattern(s),
    e.g., "path/pattern1/pattern2". The pattern can include meta chars (*, ?).
    The first match is used, but all matches are displayed.
    Use listw to lists stored paths, and editw to edit the list.
EOF
    return 0
  }

  list_dirs() {
    find ${1} -follow -type d -prune 2>/dev/null
  }

  [ $# -lt 1 ] && { usage; return 2; }
  local x firstDir tmp p=$1
  shift

  for x in "$@"; do           # (Note: [[]] acts as quotes, prevents expansion).
    if [[ -d $p/$x ]]; then  # If exists and is dir, don't use wildcarding,
      p="${p}/${x}"          #  add to list of directory matches.
    else                     # Else, since the exact path doesn't exist,
      p="${p}/${x}*"         #  add a wildcard to the end of the path
    fi
  done

  echo "pattern: $p"          # if $p is unquoted, expand metachars to full path
  echo "matches: $(list_dirs $p | tr '\n' ',')"

  if [[ -d $p ]]; then        # if dir exists (e.g., "foobar") then cd into it;
    firstDir=$p               # else it is a pattern (e.g., "foo*"),
  else                        # find the first directory in the path
    firstDir=$(list_dirs $p | head -1)
    echo "first matching directory: $firstDir"
  fi
  cd "$firstDir"
}

############################################################################
# chdir into home [ pattern ] [ pattern ... ]
cdh () { cdto "$HOME" "$@"; }

############################################################################
# List the contents of the list of current 'working directories'.
# If a directory  in the list no longer exists, it's printed with a "#" prefix.
# Options:
#   -q   - omit missing directories completely from the results
listw () {
  local d pat print_missing=true

  usage() {
    printf "Usage:  listw [pattern1] [pattern2...]\n"
    printf " Show existing saved working directories matching the given pattern.\n\n"
    return 0
  }

  printdir() {
    local line
    while read line ; do
      if [ -d "$line" ]; then
        printf "${line}\n"
      elif $print_missing ; then
        printf "#${line}\n"
      fi
    done
    return 0
  }

  [ $# -gt 0 -a "$1" = "-q" ] && print_missing=false && shift
  [ $# -gt 0 -a "$1" = "-h" ] && usage && return 1

  if [ $# -gt 0 ]; then
    d=( $@ )
    pat=$(for x in ${d[@]}; do  printf "${x}.*"; done)
    egrep "$pat" $(get_workrc) | printdir
  else
    cat $(get_workrc) | printdir
  fi
  return 0
}

############################################################################
# edit the list of current 'working directories' using $EDITOR
editw () {
  ${EDITOR:-vi} $(get_workrc)
}

############################################################################
# Usage: cdw [pattern] [prefix1] [prefix2...]
# Change directory to last working directory set in the WORKRC file.
#    [pattern]    - go to the last directory matching the given pattern
#    [prefix1...] - after going to the directory, try to cd into the
#                    subdirectory matching the given prefix.
#
#   "setwk" adds PWD to the end of the list of working directories
cdw() {
  local wkdir

  usage() { cat<<EOF
  Usage:  cdw [pattern] [prefix1] [prefix2...]
    Search the list of saved working directores for "pattern", then cd into that
    matching directory. If additional arguments are given, attempt to cd further into
    subdirectories, e.g., cd matching_dir/pattern1*/pattern2*
    Use 'listw [pattern]' to list saved working directories, and 'setwk' to add the
    current working directory to the saved list.
EOF
    return 0
  }

  if [ $# -ge 1 ]; then
    [ "$1" = "-h" -o ${1:0:1} = "-" ] && { usage ; return 1; }
    wkdir=$(egrep -- "$1" $(get_workrc) | tail -1)
    shift
  else
    wkdir=$(tail -1 $(get_workrc) )
  fi

  echo "going to work: $wkdir"
  cdto "$wkdir" "$@"
}

############################################################################
# Chdir to the last directory we were in when we last logged out.
# See also: .bash_logout, which writes to .lastdir
cdlastdir () {
  local pat="." lastdir="."
  [ $# -ge 1 ] && pat=$1 && shift
  [ -f $HOME/.lastdir ] \
       && lastdir=$(egrep -- "$pat" $HOME/.lastdir | tail -1) 2>/dev/null \
       || lastdir=$(listw -q "$pat" | tail -1) 2>/dev/null

  echo "going to work: $lastdir"
  cdto "$lastdir" "$@"
}

############################################################################
# Add $PWD to the end of the remembered list
setwk() {
  local wkdir=$PWD
  [ ! -f $WORKRC ] && cat $(get_workrc_default) >> $WORKRC
  echo "$wkdir" >> $WORKRC
  echo "work set to: $wkdir"
}

# return true
:
